# @see https://mofanpy.com/tutorials/data-manipulation/np-pd/np-math2/
import numpy as np

A = np.arange(14, 2, -1).reshape((3, 4))
print(A)
# [[14 13 12 11]
#  [10  9  8  7]
#  [ 6  5  4  3]]
print(np.sort(A))

# [[11 12 13 14]
#  [ 7  8  9 10]
#  [ 3  4  5  6]]

# 矩阵转置
print(np.transpose(A))
# [[14 10  6]
#  [13  9  5]
#  [12  8  4]
#  [11  7  3]]
print(A.T)
# [[14 10  6]
#  [13  9  5]
#  [12  8  4]
#  [11  7  3]]
#
#
print(np.clip(A,5,9))
# 这个函数的格式是clip(Array,Array_min,Array_max)，顾名思义，Array指的是将要被执行用的矩阵，而后面的最小值最大值则用于让函数判断矩阵中元素是否有比最小值小的或者比最大值大的元素，并将这些指定的元素转换为最小值或者最大值。


print("================================================")

A = np.arange(2, 14).reshape((3, 4))
print(A)

# [[ 2  3  4  5]
#  [ 6  7  8  9]
#  [10 11 12 13]]


# 矩阵中最小元素和最大元素的索引
print(np.argmin(A))
# 0
print("-----------------------------------------------")
print(np.argmax(A))
# 11
print("-----------------------------------------------")
# 如果需要计算统计中的均值，可以利用下面的方式，将整个矩阵的均值求出来：
print(np.mean(A))
print(np.average(A))
print(A.mean())

# 我们可以写出求解中位数的函数：
# print(A.median())
# print(np.median(A))

print("-----------------------------------------------")
# 和matlab中的cumsum()累加函数类似，
print(np.cumsum(A))
# [ 2  5  9 14 20 27 35 44 54 65 77 90]

print("-----------------------------------------------")
# 相应的有累差运算函数：
print(np.diff(A))
# [[1 1 1]
#  [1 1 1]
#  [1 1 1]]


print("================================================")

print(np.nonzero(A))
# (array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]), array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]))

print("================================================")
